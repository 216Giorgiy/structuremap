<!--Title: Resolving Services-->

<markdown>

While in most systems you would probably only resolve the default service of a type or a named instance of a service, there are far more ways to resolve services
exposed by StructureMap.

<TableOfContents />

<Section title="Resolving Services" id="resolving">

The `IContainer` interface acts as a [Service Locator](http://en.wikipedia.org/wiki/Service_locator_pattern) to build and resolve configured services on demand.

This will be the easy part of interacting with StructureMap. During application execution, you will be needing the services you registered in the container. When you resolve a service, depending on the <TopicLink name="object-lifecycle" />, a new instance of the service will be created by StructureMap or StructureMap is delegating the responsibility of resolving the instance to external code. This all depends on your configuration for that specific service. All of our examples so far let's StructureMap create the instance for the service.

In our bootstrapping of the container we didn't specified any lifecycle. In short, a lifecycle let's you specify how long an instance is tracked by StructureMap. More information on this subject can be found in the <TopicLink name="object-lifecycle" /> chapter. The default lifecycle for all services is [`Transient`](). This means that a new instance will be created for each request to the container. These instances aren't tracked by the container. Lifecycles for services can be defined through code or XML.

Before we can resolve services from the container, we need an reference to a `Container` object or `ObjectFactory`. For our examples we are going to use the static `ObjectFactory` class, which is StructureMap's implementation of a [Service Locator](http://todo.com).

<Snippet name="quickstart-resolve-strongly-typed-instance" />

This will create an instance of the class `Foo`. Before creating this instance, StructureMap will inspect the constructor and see that it needs to supply an instance of `IBar`. Because we also provided configuration for `IBar`, StructureMap wil be able to create an instance of the `Bar` class and injects that into the constructor of the `Foo` class. The resulting instance of `Foo` will be returned to the caller.

StructureMap is also able to resolve weakly typed services. When you only have a `Type` object that you need to  get resolved, you can use the non generic `GetInstance` method.

<Snippet name="quickstart-resolve-weakly-typed-instance" />

Both `GetInstance` methods will provide you the default instance of the `IFoo`. That is, StructureMap could have multiple configurations for the `IFoo` plugin type, but can only have one default instance. Let's alter the configuration so that there will be two `IFoo` registrations.

<Snippet name="quickstart-configure-multiple-services-of-the-same-type" />

The last registration for `IFoo` will be the default instance. So whenever you want to resolve the service `IFoo` you will get an instance of `SomeOtherFoo`. But what if you want all foo's? That's easy.

<Snippet name="quickstart-resolve-all-instances-of-foo" />

When you request a service that's unknown to StructureMap you will be presented with a StructureMap exception, complaining that there is no default instance defined for the requested service type. If you don't want this exception to occur you can use the `TryGetInstance` method. 

<Snippet name="quickstart-resolve-unknown-instance-blah" />

This will try to create or find the default instance of the requested service type. It will returns the default value (i.e. `null`) of the requested service if it's not known to the container. The condition of the assertion will be false because `blahInstance` will be `null`.

StructureMap's `ObjectFactory` class should be used with caution because a [Service Locator]() is largely considered an anti-pattern. Meaning the use of the `ObjectFactory` class through your code is not recommended. Typically, you must try to minimize the number of service locator usages in your system to a bare minimum. Most of the value of an IoC tool is in automatically doing Dependency Injection. This is possible by a feature called <TopicLink name="the-container/auto-wiring" /> and can most effectivly be utilized in your application's [integration](#integration) setup. This ensures  that needed services get resolved from a central, top level location in your application, making the need for manual resolution rare.


</Section>

</markdown>

